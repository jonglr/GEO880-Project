max_points <- c(cycling = 5, jogging = 4, hiking = 5, skitouring = 4)
for (i in 1:nrow(entry)) {
speed <- entry$speed[i]
elevation <- entry$elev_change[i]
street_distance <- entry$distance_street[i]
hiking_path_distance <- entry$distance_wander[i]
month <- entry$month[i]
# Criteria
if (speed > 15) points["cycling"] <- points["cycling"] + 1
if (speed > 5 & speed <= 15) points["jogging"] <- points["jogging"] + 1
if (speed > 2 & speed <= 5) points["hiking"] <- points["hiking"] + 1
if (abs(elevation) < 0.1) points["jogging"] <- points["jogging"] + 1
if (abs(elevation) > 0.1 & abs(elevation) <= 0.4) {
points["skitouring"] <- points["skitouring"] + 1
points["hiking"] <- points["hiking"] + 1
}
if (abs(elevation) > 0.4) points["cycling"] <- points["cycling"] + 1
if (street_distance > 100) {
points["hiking"] <- points["hiking"] + 1
points["skitouring"] <- points["skitouring"] + 1
}
if (street_distance <= 100) {
points["jogging"] <- points["jogging"] + 1
points["cycling"] <- points["cycling"] + 1
}
if (hiking_path_distance > 1000) {
points["jogging"] <- points["jogging"] + 1
points["cycling"] <- points["cycling"] + 1
}
if (hiking_path_distance <= 1000) {
points["hiking"] <- points["hiking"] + 1
points["skitouring"] <- points["skitouring"] + 1
}
if (month %in% c(11:12, 1:5)) points["skitouring"] <- points["skitouring"] + 1
if (month %in% 6:10) {
points["hiking"] <- points["hiking"] + 1
points["cycling"] <- points["cycling"] + 1
}
# Additional checks
if (month %in% 7:10) points["skitouring"] <- 0
if (speed > 8) points["hiking"] <- 0
if (street_distance > 40) points["cycling"] <- 0
max_point_ratio <- points / max_points
class_type <- names(which.max(max_point_ratio))
entry$class_type[i] <- class_type
entry$points_cycling[i] <- points["cycling"]
entry$points_jogging[i] <- points["jogging"]
entry$points_hiking[i] <- points["hiking"]
entry$points_skitouring[i] <- points["skitouring"]
}
return(entry)
}
classified_entries <- lapply(sf_obj_month, classify_entry)
return(classified_entries)
}
classified_tracks <- classify_gpx_tracks(sf_obj_month)
View(classified_tracks)
View(classified_tracks[[17]])
classify_gpx_tracks <- function(sf_obj_month) {
classify_entry <- function(entry) {
for (i in 1:nrow(entry)) {
points <- c(cycling = 0, jogging = 0, hiking = 0, skitouring = 0)
max_points <- c(cycling = 5, jogging = 4, hiking = 5, skitouring = 4)
speed <- entry$speed[i]
elevation <- entry$elev_change[i]
street_distance <- entry$distance_street[i]
hiking_path_distance <- entry$distance_wander[i]
month <- entry$month[i]
# Criteria
if (speed > 15) points["cycling"] <- points["cycling"] + 1
if (speed > 5 & speed <= 15) points["jogging"] <- points["jogging"] + 1
if (speed > 2 & speed <= 5) points["hiking"] <- points["hiking"] + 1
if (abs(elevation) < 0.1) points["jogging"] <- points["jogging"] + 1
if (abs(elevation) > 0.1 & abs(elevation) <= 0.4) {
points["skitouring"] <- points["skitouring"] + 1
points["hiking"] <- points["hiking"] + 1
}
if (abs(elevation) > 0.4) points["cycling"] <- points["cycling"] + 1
if (street_distance > 100) {
points["hiking"] <- points["hiking"] + 1
points["skitouring"] <- points["skitouring"] + 1
}
if (street_distance <= 100) {
points["jogging"] <- points["jogging"] + 1
points["cycling"] <- points["cycling"] + 1
}
if (hiking_path_distance > 1000) {
points["jogging"] <- points["jogging"] + 1
points["cycling"] <- points["cycling"] + 1
}
if (hiking_path_distance <= 1000) {
points["hiking"] <- points["hiking"] + 1
points["skitouring"] <- points["skitouring"] + 1
}
if (month %in% c(11:12, 1:5)) points["skitouring"] <- points["skitouring"] + 1
if (month %in% 6:10) {
points["hiking"] <- points["hiking"] + 1
points["cycling"] <- points["cycling"] + 1
}
# Additional checks
if (month %in% 7:10) points["skitouring"] <- 0
if (speed > 8) points["hiking"] <- 0
if (street_distance > 40) points["cycling"] <- 0
max_point_ratio <- points / max_points
class_type <- names(which.max(max_point_ratio))
entry$class_type[i] <- class_type
entry$points_cycling[i] <- points["cycling"]
entry$points_jogging[i] <- points["jogging"]
entry$points_hiking[i] <- points["hiking"]
entry$points_skitouring[i] <- points["skitouring"]
}
return(entry)
}
classified_entries <- lapply(sf_obj_month, classify_entry)
return(classified_entries)
}
classified_tracks <- classify_gpx_tracks(sf_obj_month)
View(classified_tracks)
View(classified_tracks[[5]])
classify_gpx_tracks <- function(sf_obj_month) {
classify_entry <- function(entry) {
for (i in 1:nrow(entry)) {
points <- c(cycling = 0, jogging = 0, hiking = 0, skitouring = 0)
max_points <- c(cycling = 5, jogging = 4, hiking = 5, skitouring = 4)
speed <- entry$speed[i]
elevation <- entry$elev_change[i]
street_distance <- entry$distance_street[i]
hiking_path_distance <- entry$distance_wander[i]
month <- entry$month[i]
# Criteria
if (speed > 15) points["cycling"] <- points["cycling"] + 1
if (speed > 5 & speed <= 15) points["jogging"] <- points["jogging"] + 1
if (speed > 2 & speed <= 5) points["hiking"] <- points["hiking"] + 1
if (abs(elevation) < 0.1) points["jogging"] <- points["jogging"] + 1
if (abs(elevation) > 0.1 & abs(elevation) <= 0.4) {
points["skitouring"] <- points["skitouring"] + 1
points["hiking"] <- points["hiking"] + 1
}
if (abs(elevation) > 0.4) points["cycling"] <- points["cycling"] + 1
if (street_distance > 100) {
points["hiking"] <- points["hiking"] + 1
points["skitouring"] <- points["skitouring"] + 1
}
if (street_distance <= 100) {
points["jogging"] <- points["jogging"] + 1
points["cycling"] <- points["cycling"] + 1
}
if (hiking_path_distance > 1000) {
points["jogging"] <- points["jogging"] + 1
points["cycling"] <- points["cycling"] + 1
}
if (hiking_path_distance <= 1000) {
points["hiking"] <- points["hiking"] + 1
points["skitouring"] <- points["skitouring"] + 1
}
if (month %in% c(11:12, 1:5)) points["skitouring"] <- points["skitouring"] + 1
if (month %in% 6:10) {
points["hiking"] <- points["hiking"] + 1
points["cycling"] <- points["cycling"] + 1
}
# Additional checks
if (month %in% 7:10) points["skitouring"] <- 0
if (speed > 8) points["hiking"] <- 0
if (street_distance > 40) points["cycling"] <- 0
max_point_ratio <- points / max_points
class_type <- names(which.max(max_point_ratio))
# Calculate certainty
certainty <- max(max_point_ratio)
entry$class_type[i] <- class_type
entry$certainty[i] <- certainty
entry$points_cycling[i] <- points["cycling"]
entry$points_jogging[i] <- points["jogging"]
entry$points_hiking[i] <- points["hiking"]
entry$points_skitouring[i] <- points["skitouring"]
}
return(entry)
}
classified_entries <- lapply(sf_obj_month, classify_entry)
return(classified_entries)
}
classified_tracks <- classify_gpx_tracks(sf_obj_month)
View(classified_tracks)
View(classified_tracks[[6]])
View(classified_tracks)
View(classified_tracks[[2]])
View(classified_tracks[[16]])
View(classified_tracks[[5]])
View(classified_tracks[[10]])
View(classified_tracks[[11]])
classify_gpx_tracks <- function(sf_obj_month) {
classify_entry <- function(entry) {
for (i in 1:nrow(entry)) {
points <- c(cycling = 0, running= 0, hiking = 0, skitouring = 0)
max_points <- c(cycling = 5, running = 4, hiking = 5, skitouring = 4)
speed <- entry$speed[i]
elevation <- entry$elev_change[i]
street_distance <- entry$distance_street[i]
hiking_path_distance <- entry$distance_wander[i]
month <- entry$month[i]
# Criteria
if (speed > 15) points["cycling"] <- points["cycling"] + 1
if (speed > 5 & speed <= 15) points["running"] <- points["running"] + 1
if (speed > 2 & speed <= 5) points["hiking"] <- points["hiking"] + 1
if (abs(elevation) < 0.1) points["running"] <- points["running"] + 1
if (abs(elevation) > 0.1 & abs(elevation) <= 0.4) {
points["skitouring"] <- points["skitouring"] + 1
points["hiking"] <- points["hiking"] + 1
}
if (abs(elevation) > 0.4) points["cycling"] <- points["cycling"] + 1
if (street_distance > 100) {
points["hiking"] <- points["hiking"] + 1
points["skitouring"] <- points["skitouring"] + 1
}
if (street_distance <= 100) {
points["running"] <- points["running"] + 1
points["cycling"] <- points["cycling"] + 1
}
if (hiking_path_distance > 1000) {
points["running"] <- points["running"] + 1
points["cycling"] <- points["cycling"] + 1
}
if (hiking_path_distance <= 1000) {
points["hiking"] <- points["hiking"] + 1
points["skitouring"] <- points["skitouring"] + 1
}
if (month %in% c(11:12, 1:5)) points["skitouring"] <- points["skitouring"] + 1
if (month %in% 6:10) {
points["hiking"] <- points["hiking"] + 1
points["cycling"] <- points["cycling"] + 1
}
# Additional checks
if (month %in% 7:10) points["skitouring"] <- 0
if (speed > 8) points["hiking"] <- 0
if (street_distance > 40) points["cycling"] <- 0
max_point_ratio <- points / max_points
class_type <- names(which.max(max_point_ratio))
# Calculate certainty
certainty <- max(max_point_ratio)
entry$class_type[i] <- class_type
entry$certainty[i] <- certainty
entry$points_cycling[i] <- points["cycling"]
entry$points_jogging[i] <- points["running"]
entry$points_hiking[i] <- points["hiking"]
entry$points_skitouring[i] <- points["skitouring"]
}
return(entry)
}
classified_entries <- lapply(sf_obj_month, classify_entry)
return(classified_entries)
}
classified_tracks <- classify_gpx_tracks(sf_obj_month)
View(classified_tracks)
View(classified_tracks[[6]])
# Function to calculate performance metrics
calculate_metrics <- function(classified_tracks) {
all_entries <- do.call(rbind, classified_tracks)
# Calculate confusion matrix
confusion_matrix <- table(all_entries$class_type, all_entries$movement_type)
# Calculate metrics for each class
metrics <- data.frame(
Class = character(),
Accuracy = numeric(),
Precision = numeric(),
Recall = numeric(),
F1_Score = numeric(),
stringsAsFactors = FALSE
)
classes <- unique(all_entries$movement_type)
for (class in classes) {
true_positive <- confusion_matrix[class, class]
false_positive <- sum(confusion_matrix[class, ]) - true_positive
false_negative <- sum(confusion_matrix[, class]) - true_positive
true_negative <- sum(confusion_matrix) - (true_positive + false_positive + false_negative)
accuracy <- (true_positive + true_negative) / sum(confusion_matrix)
precision <- ifelse((true_positive + false_positive) == 0, 0, true_positive / (true_positive + false_positive))
recall <- ifelse((true_positive + false_negative) == 0, 0, true_positive / (true_positive + false_negative))
f1_score <- ifelse((precision + recall) == 0, 0, 2 * (precision * recall) / (precision + recall))
metrics <- rbind(metrics, data.frame(
Class = class,
Accuracy = accuracy,
Precision = precision,
Recall = recall,
F1_Score = f1_score
))
}
return(metrics)
}
# Calculate and display metrics
metrics <- calculate_metrics(classified_tracks)
View(metrics)
# Combine all GPX tracks into a single sf object
combined_tracks <- do.call(rbind, sf_obj_clean)
# Create a buffer of 1 km (1000 meters) around the combined tracks
buffered_tracks <- st_buffer(combined_tracks, dist = 1000)
# Combine all buffers into a single geometry
combined_buffer <- st_union(buffered_tracks)
# Filter the street network to keep only the streets within the buffer
filtered_streets <- streets[st_intersects(streets, combined_buffer, sparse = FALSE), ]
# Combine all GPX tracks into a single sf object
combined_tracks <- do.call(rbind, sf_obj_clean)
# Create a buffer of 1 km (1000 meters) around the combined tracks
buffered_tracks <- st_buffer(combined_tracks, dist = 1000)
# Combine all buffers into a single geometry
combined_buffer <- st_union(buffered_tracks)
# Filter the street network to keep only the streets within the buffer
filtered_streets <- streets[st_intersects(streets, combined_buffer, sparse = FALSE), ]
# Plot the results to visualize and save the plot as a PNG file
png("plot.png")
plot(st_geometry(streets), col = "gray", main = "Filtered Streets and GPX Tracks")
plot(st_geometry(filtered_streets), col = "blue", add = TRUE)
plot(st_geometry(combined_tracks), col = "red", add = TRUE)
dev.off()
# Save the filtered streets
#st_write(filtered_streets, "filtered_streets.gpkg")
# Combine all data frames into one and ensure a 'track_id' column exists
combined_data <- bind_rows(lapply(sf_obj_month, function(df) {
df$track_id <- 1:nrow(df) # create a track_id column for each dataframe
return(df)
}))
# Plotting function for each attribute
plot_attribute <- function(data, attribute, title) {
ggplot(data, aes(x = track_id, y = !!sym(attribute), color = as.factor(month))) +
geom_point(alpha = 0.7) +
labs(title = title, x = "Track ID", y = attribute, color = "Month") +
theme_minimal()
}
# Create plots for each attribute
plot_speed <- plot_attribute(combined_data, "speed", "Speed (km/h)")
plot_elev_change <- plot_attribute(combined_data, "elev_change", "Elevation Change (m)")
plot_distance_street <- plot_attribute(combined_data, "distance_street", "Distance to Street (m)")
plot_distance_wander <- plot_attribute(combined_data, "distance_wander", "Distance to Wanderweg (m)")
plot_month <- ggplot(combined_data, aes(x = track_id, y = month, color = as.factor(month))) +
geom_point(alpha = 0.7) +
labs(title = "Month", x = "Track ID", y = "Month", color = "Month") +
theme_minimal()
# Arrange all plots in a grid
png("grid_plot.png", width = 800, height = 800)
grid.arrange(plot_speed, plot_elev_change, plot_distance_street, plot_distance_wander, plot_month, ncol = 2)
dev.off()
# Function to calculate performance metrics
calculate_metrics <- function(classified_tracks) {
all_entries <- do.call(rbind, classified_tracks)
# Calculate confusion matrix
confusion_matrix <- table(all_entries$class_type, all_entries$movement_type)
# Calculate metrics for each class
metrics <- data.frame(
Class = character(),
Accuracy = numeric(),
Precision = numeric(),
Recall = numeric(),
F1_Score = numeric(),
stringsAsFactors = FALSE
)
classes <- unique(all_entries$movement_type)
for (class in classes) {
true_positive <- confusion_matrix[class, class]
false_positive <- sum(confusion_matrix[class, ]) - true_positive
false_negative <- sum(confusion_matrix[, class]) - true_positive
true_negative <- sum(confusion_matrix) - (true_positive + false_positive + false_negative)
accuracy <- (true_positive + true_negative) / sum(confusion_matrix)
precision <- ifelse((true_positive + false_positive) == 0, 0, true_positive / (true_positive + false_positive))
recall <- ifelse((true_positive + false_negative) == 0, 0, true_positive / (true_positive + false_negative))
f1_score <- ifelse((precision + recall) == 0, 0, 2 * (precision * recall) / (precision + recall))
metrics <- rbind(metrics, data.frame(
Class = class,
Accuracy = accuracy,
Precision = precision,
Recall = recall,
F1_Score = f1_score
))
}
return(metrics)
}
# Calculate and display metrics
metrics <- calculate_metrics(classified_tracks)
write.csv(metrics, "metrics.csv", row.names = FALSE)
View(classified_tracks)
View(classified_tracks)
View(classified_tracks[[3]])
# Function to create an interactive map
create_interactive_map <- function(classified_tracks) {
# Combine all entries into a single sf object
all_tracks <- do.call(rbind, classified_tracks)
# Create a color palette for class_type
class_palette <- colorFactor(topo.colors(length(unique(all_tracks$class_type))), domain = all_tracks$class_type)
# Create the leaflet map
map <- leaflet(all_tracks) %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addCircleMarkers(
radius = ~certainty * 10, # Scale the point size by certainty
color = ~class_palette(class_type), # Color by class_type
fillOpacity = 0.7,
stroke = FALSE,
label = ~paste("Class:", class_type, "<br>", "Certainty:", round(certainty, 2))
) %>%
addLegend("bottomright", pal = class_palette, values = ~class_type, title = "Class Type",
opacity = 0.7)
return(map)
}
interactive_map <- create_interactive_map(classified_tracks)
interactive_map
# Function to create an interactive map
create_interactive_map <- function(classified_tracks) {
# Combine all entries into a single sf object
all_tracks <- do.call(rbind, classified_tracks)
# Transform coordinates from LV95 to WGS84
all_tracks <- st_transform(all_tracks, crs = 4326)
# Create a color palette for class_type
class_palette <- colorFactor(topo.colors(length(unique(all_tracks$class_type))), domain = all_tracks$class_type)
# Create the leaflet map
map <- leaflet(all_tracks) %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addCircleMarkers(
radius = ~certainty * 10, # Scale the point size by certainty
color = ~class_palette(class_type), # Color by class_type
fillOpacity = 0.7,
stroke = FALSE,
label = ~paste("Class:", class_type, "<br>", "Certainty:", round(certainty, 2))
) %>%
addLegend("bottomright", pal = class_palette, values = ~class_type, title = "Class Type",
opacity = 0.7)
return(map)
}
interactive_map <- create_interactive_map(classified_tracks)
interactive_map
# Function to create an interactive map
create_interactive_map <- function(classified_tracks) {
# Combine all entries into a single sf object
all_tracks <- do.call(rbind, classified_tracks)
# Transform coordinates from LV95 to WGS84
all_tracks <- st_transform(all_tracks, crs = 4326)
# Create a color palette for class_type
class_palette <- colorFactor(topo.colors(length(unique(all_tracks$class_type))), domain = all_tracks$class_type)
# Define a function to scale certainty for better visualization
scale_certainty <- function(certainty) {
return(certainty * 10) # Adjust the multiplier for better visualization
}
# Create the leaflet map
map <- leaflet(all_tracks) %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addCircleMarkers(
radius = ~scale_certainty(certainty), # Scale the point size by certainty
color = ~class_palette(class_type), # Color by class_type
fillOpacity = 0.7,
stroke = FALSE,
label = ~paste("Class:", class_type, "<br>", "Certainty:", round(certainty, 2))
) %>%
addLegend("bottomright", pal = class_palette, values = ~class_type, title = "Class Type",
opacity = 0.7) %>%
addLegend("bottomleft", colors = c("red", "orange", "yellow", "green", "blue"),
labels = c("0.1", "0.3", "0.5", "0.7", "0.9"), title = "Certainty",
opacity = 0.7)
return(map)
}
interactive_map <- create_interactive_map(classified_tracks)
interactive_map
install.packages("html.widgets")
install.packages("htmlwidgets")
check_pkg <- function(x) {
#' Checks whether a package is installed and installs or loads the package
if (!require(x, character.only = TRUE, quietly = TRUE))
{
install.packages(x, dep = TRUE)
if (!require(x, character.only = TRUE, quietly = TRUE))
stop("Package not found")
}
}
check_pkg("readr")
check_pkg("dplyr")
check_pkg("sf")
check_pkg("sp")
check_pkg("ggplot2")
check_pkg("lubridate")
check_pkg("SimilarityMeasures")
check_pkg("plotly")
check_pkg("geosphere")
check_pkg("leaflet")
check_pkg("ggspatial")
check_pkg("rnaturalearth")
check_pkg("rnaturalearthdata")
check_pkg("tidyverse")
check_pkg("XML")
check_pkg("here")
check_pkg("gridExtra")
check_pkg("rlang")
check_pkg("htmlwidgets")
Data <- here::here()   # Data folder
# Function to create an interactive map
create_interactive_map <- function(classified_tracks) {
# Combine all entries into a single sf object
all_tracks <- do.call(rbind, classified_tracks)
# Transform coordinates from LV95 to WGS84
all_tracks <- st_transform(all_tracks, crs = 4326)
# Create a color palette for class_type
class_palette <- colorFactor(topo.colors(length(unique(all_tracks$class_type))), domain = all_tracks$class_type)
# Create the leaflet map
map <- leaflet(all_tracks) %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addCircleMarkers(
radius = ~certainty * 10, # Scale the point size by certainty
color = ~class_palette(class_type), # Color by class_type
fillOpacity = 0.7,
stroke = FALSE,
label = ~paste("Class:", class_type, "<br>", "Certainty:", round(certainty, 2))
) %>%
addLegend("bottomright", pal = class_palette, values = ~class_type, title = "Class Type",
opacity = 0.7)
return(map)
}
interactive_map <- create_interactive_map(classified_tracks)
# Save the map as an HTML file
saveWidget(interactive_map, "interactive_map.html", selfcontained = TRUE)
