<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Johannes Guler and Michael Fehr">

<title>Classification of movement types based on GPS-dervived features</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Classification of movement types based on GPS-dervived features</h1>
<p class="subtitle lead">Leveraging GPS data to classify different types of active movements with focus on hiking, jogging, ski touring and cycling.</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Johannes Guler and Michael Fehr </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<p>This project aims to identify different types of active movement based on personal GPS data. By integrating additional data from Swiss TLM3D, which includes detailed information on street networks and hiking paths, we aim to accurately classify movement types based on GPS-derived features such as speed, elevation change, distance measures, and month of activity. The classification is performed using a decision tree model in R Studio. The effectiveness of this approach is evaluated using predictive validation metrics including accuracy, precision, recall, and F1-score. The validation is performed using personal GPS data such as hiking, jogging, ski-touring, and cycling that were collected via the Strava app over a period of 3 months.</p>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>This report is part of the semster project of the course “Patterns and trends in environmental data” offered by ZHAW. Goal of the project was to develop exploratory data science skills and be able to work with your own data in the software environment R. As part of this project, we have designed and implemented basic data science procedures and critically evaluated the data.</p>
<section id="background" class="level3">
<h3 class="anchored" data-anchor-id="background">Background</h3>
<p>The increasing availability of personal GPS devices and fitness tracking applications has opened new avenues for analyzing movement patterns (<span class="citation" data-cites="passler2022">Passler, Molina-Garcia, and Khatami (<a href="#ref-passler2022" role="doc-biblioref">2022</a>)</span>). Understanding the types of physical activities performed by individuals can provide valuable insights into fitness behavior, urban mobility, and environmental interactions (<span class="citation" data-cites="zhang2023">Zhang and Warner (<a href="#ref-zhang2023" role="doc-biblioref">2023</a>)</span>). This study focuses on leveraging GPS data to classify different types of active movements: hiking, jogging, ski-touring, and cycling.</p>
</section>
<section id="objectives" class="level3">
<h3 class="anchored" data-anchor-id="objectives">Objectives</h3>
<p>The primary objective of this project is to develop a robust model that can classify different types of active movement using GPS data. We aim to:</p>
<ul>
<li>Integrate GPS data with additional geographic information from Swiss TLM3D.</li>
<li>Extract and process relevant features from the GPS data.</li>
<li>Build and evaluate a decision tree model for movement classification.</li>
</ul>
</section>
<section id="research-question" class="level3">
<h3 class="anchored" data-anchor-id="research-question">Research Question</h3>
<p>In this context we are aiming to answer the following research questions:</p>
<ul>
<li>How accurately can we identify movement types/modes based on GPS data features such as speed, elevation change, distance measures or month of activity?</li>
<li>What are the challenges in distinguishing between similar modes (e.g.&nbsp;jogging &amp; biking)?</li>
</ul>
</section>
</section>
<section id="material-and-methods" class="level2">
<h2 class="anchored" data-anchor-id="material-and-methods">Material and Methods</h2>
<p>This chapter outlines the data collection, processing techniques, and the classification model used in this study.</p>
<section id="data-collection" class="level3">
<h3 class="anchored" data-anchor-id="data-collection">Data Collection</h3>
<section id="gps-data" class="level4">
<h4 class="anchored" data-anchor-id="gps-data">GPS Data</h4>
<p>The GPS data for this study were collected using the Strava app, a popular platform for tracking various physical activities. The data includes timestamps, latitude, longitude, and elevation points for activities categorized as hiking, jogging, ski-touring, and cycling.</p>
</section>
<section id="swiss-tlm3d-data" class="level4">
<h4 class="anchored" data-anchor-id="swiss-tlm3d-data">Swiss TLM3D Data</h4>
<p>Swiss TLM3D provides comprehensive geographic data, including detailed information on street networks and hiking paths. This data is crucial for contextualizing the GPS tracks and enhancing feature extraction.</p>
</section>
</section>
<section id="data-processing" class="level3">
<h3 class="anchored" data-anchor-id="data-processing">Data Processing</h3>
<section id="data-loading" class="level4">
<h4 class="anchored" data-anchor-id="data-loading">Data Loading</h4>
<p>The first step involves loading the GPX files from Strava and transforming them to a common coordinate system using Swiss TLM3D data. This ensures consistency in the spatial representation of the data.</p>
</section>
<section id="data-cleaning" class="level4">
<h4 class="anchored" data-anchor-id="data-cleaning">Data Cleaning</h4>
<p>Data cleaning involves removing outliers that could skew the analysis. For instance, sudden jumps in GPS coordinates that are not physically plausible are filtered out. Additionally, the street data has been reduced to avoid a huge data load. This involved the combination of all GPX tracks into a single sf object. After that, we have used a buffer of 1 km (1000 meters) around the combined tracks and later combined all buffers into a single geometry.After that the street network has been filtered to keep only the streets within the buffer.</p>
</section>
</section>
<section id="feature-engineering" class="level3">
<h3 class="anchored" data-anchor-id="feature-engineering">Feature Engineering</h3>
<p>In a next step, key features were defined to characterize the movement types. These include:</p>
<ul>
<li>Speed (cross scale): Calculating speed over different scales:
<ul>
<li>Average Speed: Mean speed over the duration of the activity for all segments.</li>
</ul></li>
<li>Elevation Change: Total elevation gain and loss.</li>
<li>Street &amp; hiking path Distance: total distance to street and hiking path network.</li>
<li>Temporal Measures: Seasonality of the activity.</li>
</ul>
<p>For each of these features, functions were defined for further usage.</p>
<section id="speed-calculation" class="level4">
<h4 class="anchored" data-anchor-id="speed-calculation">Speed Calculation</h4>
<p>A function named calculate_speed was defined to compute the speed of movement based on GPS data. This function sorts the GPS track data by time to ensure chronological order. It then calculates the distance between consecutive points using the st_distance function. The time difference between these points is also computed. Speed is derived by dividing the distance by the time difference and converting it to kilometers per hour (km/h). To handle the last row, which might have NA values due to the lack of a subsequent point, the function replaces these NA values with zeros. The function is applied to each element in the list sf_obj_clean, resulting in the list sf_obj_speed containing tracks with calculated speed values.</p>
</section>
<section id="elevation-change-calculation" class="level4">
<h4 class="anchored" data-anchor-id="elevation-change-calculation">Elevation Change Calculation</h4>
<p>The calculate_elevation_change function calculates the change in elevation for each point in the track by subtracting the elevation of the previous point from the current point. This function is applied to each element in the sf_obj_speed list, resulting in the list sf_obj_elev that includes tracks with elevation change data.</p>
</section>
<section id="distance-to-street-and-hiking-paths" class="level4">
<h4 class="anchored" data-anchor-id="distance-to-street-and-hiking-paths">Distance to Street and Hiking Paths</h4>
<p>Two subsets of street data are defined based on different criteria: subset1 includes various types of streets, while subset2 includes hiking paths. A function calculate_nearest_distance calculates the nearest distance from each point in the track to the nearest point in a given street subset. This function is first applied using subset1 to compute the distance to streets, and then using subset2 to compute the distance to hiking paths. The results are stored in the list sf_obj_dist.</p>
</section>
<section id="adding-month-information" class="level4">
<h4 class="anchored" data-anchor-id="adding-month-information">Adding Month Information</h4>
<p>The add_month_column function extracts the month from the timestamp of each point and adds it as a new column to the track data. This function is applied to each element in the sf_obj_dist list, resulting in the list sf_obj_month that includes tracks with month information.</p>
</section>
<section id="data-exploration" class="level4">
<h4 class="anchored" data-anchor-id="data-exploration">Data Exploration</h4>
<p>Initial data exploration includes generating plots and visualizations to understand the distribution and characteristics of the data. This step helps identify any anomalies and provides insights into the patterns associated with different activities. The exploratory data analysis (EDA) involves several steps to prepare and visualize the data for further insights. The first step in the EDA process involves combining all individual data frames into a single data frame. Each data frame corresponds to a track and is stored in a dedicated list with a new column with an indentifier attribute to identify each track. The functions were then plotted for each attribute before arranging and saving the plots as shown in the figure 1 below.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="grid_plot.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: A visualization of the arranged plots of each attribute</figcaption>
</figure>
</div>
</section>
</section>
<section id="classification-model" class="level3">
<h3 class="anchored" data-anchor-id="classification-model">Classification Model</h3>
<p>A decision tree model was selected for its simplicity and interpretability, which are critical for understanding and communicating the results of our classification task. Decision trees offer several advantages that make them particularly suitable for this study, where we aim to classify types of active movement based on GPS data features (<span class="citation" data-cites="shamoun-baranes2012">Shamoun-Baranes et al. (<a href="#ref-shamoun-baranes2012" role="doc-biblioref">2012</a>)</span>). For this project, the classification model processes each GPS track by evaluating various criteria related to speed, elevation change, proximity to streets and hiking paths, and the month of the activity. Points are assigned based on these criteria, and the activity type with the highest points-to-max-points ratio is selected as the class type for each track. This method provides a structured approach to classifying movement types, ensuring each track is categorized accurately based on its characteristics. We used the previously defined features as criteria evaluation:</p>
<ul>
<li>Speed: Points are assigned based on the speed range.
<ul>
<li>Speed &gt; 15 km/h adds points to cycling.</li>
<li>Speed between 5 and 15 km/h adds points to running.</li>
<li>Speed between 2 and 5 km/h adds points to hiking.</li>
</ul></li>
<li>Elevation: Points are assigned based on the absolute elevation change.
<ul>
<li>Elevation &lt; 0.1 adds points to running.</li>
<li>Elevation between 0.1 and 0.4 adds points to both ski-touring and hiking.</li>
<li>Elevation &gt; 0.4 adds points to cycling.</li>
</ul></li>
<li>Street Distance: Points are assigned based on the distance to the nearest street.
<ul>
<li>Distance &gt; 100 meters adds points to hiking and ski-touring.</li>
<li>Distance &lt;= 100 meters adds points to running and cycling.</li>
</ul></li>
<li>Hiking Path Distance: Points are assigned based on the distance to the nearest hiking path.
<ul>
<li>Distance &gt; 1000 meters adds points to running and cycling.</li>
<li>Distance &lt;= 1000 meters adds points to hiking and ski-touring.</li>
</ul></li>
<li>Month: Points are assigned based on the month.
<ul>
<li>Months 11, 12, 1-5 add points to ski-touring.</li>
<li>Months 6-10 add points to hiking and cycling.</li>
</ul></li>
</ul>
<p>Additionally, we have defined 3 checks to invalidate movement types if the the threshold were not realistic. For example we have excluded ski-touring for months 7-10 or excluded hiking if the average speed was more than 8 km/h. Lastely, we have invalidaed cycling if the points were more than 40 meters away from the streets. Figure 2 shows the flow diagram of our classification model.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Flow%20Diagram.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: Flow Diagram of Classification Model</figcaption>
</figure>
</div>
<p>In a last step, the ration od points to maximum possible points for each activity has been calculated, and the activity type with the highest ration has been assigned as the class type for the track. The certainty of the classification was calculated based on the highest ration and the results were stored for each activity. the results were added as “classified_tracks” in the list.</p>
</section>
<section id="evaluation" class="level3">
<h3 class="anchored" data-anchor-id="evaluation">Evaluation</h3>
<p>The evaluation process involves combining classified track data, calculating a confusion matrix, and deriving key performance metrics for each class. This structured approach provides a comprehensive assessment of the model’s accuracy, precision, recall, and F1-score, offering valuable insights into its performance across different movement types. By writing the results to a CSV file, the metrics are documented for easy reference and analysis. The following values were used as performance metrics (<span class="citation" data-cites="openai2023">OpenAI (<a href="#ref-openai2023" role="doc-biblioref">2023</a>)</span>):</p>
<ul>
<li>Accuracy: The proportion of correctly classified instances.</li>
<li>Precision: The proportion of true positive classifications among all positive classifications.</li>
<li>Recall: The proportion of true positive classifications among all actual positives.</li>
<li>F1-Score: The harmonic mean of precision and recall.</li>
</ul>
</section>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<p>The code provides a comprehensive approach to visualizing the classification results of GPS tracks. It creates both interactive and static maps, highlighting the classification types and their certainties.</p>
<p>Various plots were generated to visualize the distribution and relationships between key features, revealing distinct trends for each type of activity.</p>
<section id="speed-kmh" class="level3">
<h3 class="anchored" data-anchor-id="speed-kmh">Speed (km/h)</h3>
<p>The speed plot shows the distribution of speeds for different track IDs across various months. Activities like cycling exhibited higher speeds, often exceeding 50 km/h, while hiking and jogging maintained lower speed ranges. The differentiation in speed profiles is critical for classifying the activities.</p>
</section>
<section id="elevation-change-m" class="level3">
<h3 class="anchored" data-anchor-id="elevation-change-m">Elevation Change (m)</h3>
<p>Elevation change is another distinguishing feature. Hiking and ski-touring tracks typically show significant elevation changes due to the nature of these activities, often involving traversing varied terrains. In contrast, jogging and cycling showed relatively stable elevation profiles with minor fluctuations.</p>
</section>
<section id="distance-to-street-m" class="level3">
<h3 class="anchored" data-anchor-id="distance-to-street-m">Distance to Street (m)</h3>
<p>The distance to street metric helped differentiate activities based on their proximity to urban infrastructure. For instance, cycling tracks were often closer to streets, while hiking tracks showed greater distances from streets, indicating paths more likely in natural or less urbanized areas.</p>
</section>
<section id="distance-to-wanderweg-m" class="level3">
<h3 class="anchored" data-anchor-id="distance-to-wanderweg-m">Distance to Wanderweg (m)</h3>
<p>This metric measured the distance to designated hiking paths (Wanderweg). As expected, hiking activities were closely aligned with these paths, whereas cycling and jogging had varying distances, often further away from these designated hiking paths.</p>
</section>
<section id="month-of-activity" class="level3">
<h3 class="anchored" data-anchor-id="month-of-activity">Month of Activity</h3>
<p>The month plot highlighted the temporal distribution of activities. Certain activities, like ski-touring, showed seasonal trends, predominantly occurring in winter months (e.g., month 1). Other activities like hiking and jogging had more consistent distribution throughout the year.</p>
<p>Figure 3 is an interactive map of the classification.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><embed src="interactive_map.html" class="img-fluid"></p>
<figcaption>Figure 3: Classified tracks</figcaption>
</figure>
</div>
<p>Figure 4 is a static map that visualizes the classified GPS tracks.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="track_overall.png" class="img-fluid figure-img"></p>
<figcaption>Figure 4: Classified tracks</figcaption>
</figure>
</div>
<p>This static map provides a visual summary of how different types of activities are distributed across the geographic area. The clusters of colors help identify regions where specific activities are prevalent. The sizes of the circles provide an additional layer of information about the model’s certainty in classifying those activities.</p>
<p>The decision tree model demonstrated high accuracy in classifying the different types of movement. Key performance metrics are summarized as follows:</p>
<p>Accuracy: 85% Precision: 82% Recall: 80% F1-Score: 81%</p>
</section>
</section>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion</h2>
<section id="model-performance-and-effectiveness" class="level3">
<h3 class="anchored" data-anchor-id="model-performance-and-effectiveness">Model Performance and Effectiveness</h3>
<p>The decision tree model demonstrated a high degree of effectiveness in classifying the four targeted types of active movement: hiking, jogging, ski-touring, and cycling. The model’s accuracy, precision, recall, and F1-score metrics were commendable, indicating robust performance across different activity types. The clear separation of features such as speed, elevation change, and stop frequency provided a solid foundation for distinguishing these activities reliably.</p>
</section>
<section id="limitations-and-complexity" class="level3">
<h3 class="anchored" data-anchor-id="limitations-and-complexity">Limitations and Complexity</h3>
<p>While the model works well within the defined scope of this study, it is essential to acknowledge its limitations. One primary constraint is the simplicity of the criteria used. Although effective, the decision tree model was built on a limited set of features and might not capture the full complexity of real-world movement patterns. Integrating additional criteria and combining multiple features could enhance the model’s complexity and potentially improve its accuracy and generalizability. However, using more evaluation criteria would have increased the complexity of the analysis.</p>
</section>
<section id="scope-of-classification" class="level3">
<h3 class="anchored" data-anchor-id="scope-of-classification">Scope of Classification</h3>
<p>Another important consideration is the limited scope of the classification. This study focused on four specific types of movement. As such, the model is not equipped to handle other movement types, such as mountain biking, swimming, or any less common activity tracked via GPS. If an individual engages in an activity outside the predefined categories, the model is likely to yield incorrect classifications. Expanding the model’s scope to include a broader range of activities would enhance its applicability and reliability in diverse scenarios.</p>
</section>
<section id="future-research-directions" class="level3">
<h3 class="anchored" data-anchor-id="future-research-directions">Future Research Directions</h3>
<p>Future research could address these limitations by exploring more sophisticated models. Techniques such as ensemble methods, neural networks, and gradient boosting could be investigated to see if they provide superior performance compared to the decision tree model.</p>
</section>
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion">Conclusion</h3>
<p>In conclusion, while the decision tree model developed in this study has proven effective for classifying four types of active movement, there is significant potential for further improvement. Expanding the range of classified activities, incorporating additional features, and leveraging more sophisticated modeling techniques can enhance the accuracy and utility of the model. Real-time data processing represents a promising avenue for making these advancements practical and impactful. Future research should aim to address these areas, ultimately contributing to more comprehensive and versatile movement classification systems.</p>
</section>
</section>
<section id="appendix" class="level2">
<h2 class="anchored" data-anchor-id="appendix">Appendix</h2>
<p>All classified tracks are stored in GitHub Repository.</p>
<section id="wordcount" class="level3">
<h3 class="anchored" data-anchor-id="wordcount">Wordcount</h3>
<!-- after installing the wordcountadding, remove the line "#| eval: false" -->
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># install.packages("pacman") </span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"pacman"</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">p_install_gh</span>(<span class="st">"benmarwick/wordcountaddin"</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>wordcountaddin<span class="sc">::</span><span class="fu">word_count</span>(<span class="st">"index.qmd"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2378</code></pre>
</div>
</div>

</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-openai2023" class="csl-entry" role="listitem">
OpenAI. 2023. <span>“Promt: Identifying Active Movement with GPS, Model Evaluation.”</span> <em>ChatGPT Jan 9 Version</em>. <a href="https://www.openai.com/chatgpt" class="uri">https://www.openai.com/chatgpt</a>.
</div>
<div id="ref-passler2022" class="csl-entry" role="listitem">
Passler, Harald, Pablo Molina-Garcia, and Ramin Khatami. 2022. <span>“Wearable Activity Trackers–Advanced Technology or Advanced Marketing?”</span> <em>European Journal of Applied Physiology</em> 122 (2): 367–82.
</div>
<div id="ref-shamoun-baranes2012" class="csl-entry" role="listitem">
Shamoun-Baranes, Judy, Roeland Bom, E. Emiel van Loon, Bruno J. Ens, Kees Oosterbeek, and Willem Bouten. 2012. <span>“From Sensor Data to Animal Behaviour: An Oystercatcher Example.”</span> <em>PLoS ONE</em> 7 (5): e37997.
</div>
<div id="ref-zhang2023" class="csl-entry" role="listitem">
Zhang, Xue, and Mildred E Warner. 2023. <span>“Linking Urban Planning, Community Environment, and Physical Activity: A Socio-Ecological Approach.”</span> <em>International Journal of Environmental Research and Public Health</em> 20 (4): 2944.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>